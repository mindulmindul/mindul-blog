---
title: '【arm基础知识】ARM中的异常中断处理'
categories: [嵌入式]
tags: [S3C2440, arm, arm中断]
date: 2022-06-28
---

> 说明：大部分内容摘自《ARM体系结构与编程第2版（杜春雷）》

ARM体系中用来控制程序的执行流程的方法如下：

1. 在正常程序执行过程中，每执行一条ARM指令，程序计数器的值加四个字节。每执行一条Thumb指令，程序计数器的值加两个字节，整个过程是顺序执行的。
2. 通过跳转指令程序可以跳转到指定的地址标号处执行，或者跳转到特定的子程序处执行。其中B指令只能用于执行跳转操作；BL指令只能用于执行跳转操作，同时在LR中保存子程序的返回地址。BX指令在执行跳转操作的同时，根据目标地址最低位，可以将程序状态切换到Thumb状态。
3. 当异常中断发生时，系统执行完当前指令后将跳转到相应的异常中断处理程序处执行，当异常中断处理程序执行完成后，程序返回到发生中断的指令的下一条指令处执行。当进入异常中断处理程序时，要保存被中断程序的执行现场，在从异常中断处理程序退出时要恢复被中断的程序的执行现场。

## 1. ARM体系中的异常中断种类
ARM体系中的异常中断如表所示：

异常中断名称 | 含义
-|:-
复位（reset）| 当处理器的复位引脚有效时，系统产生复位异常中断，程序跳转到复位异常中断处理程序处执行。复位异常中断通常用在下面两种情况：1. 系统加电时；2. 系统复位时。跳转到复位中断向量处执行，称为软复位。
未定义的指令（Undefined Instruction）| 当ARM处理器或者是系统中的协处理器认为当前指令未定义时，产生未定义的指令异常中断。可以通过该异常中断机制仿真浮点向量运算。
软件中断（Software Interrupt，SWI）| 这是一个由用户定义的中断指令。可用于用户模式下的程序调用特权操作指令。在实时操作系统（RTOS）中可以通过该机制实现系统功能调用。
指令预取终止（Prefetch Abort） | 如果处理器预取指令的地址不存在，或者该地址不允许当前指令访问，当该被预取的指令执行时，处理器产生指令预取终止异常中断。
数据访问终止（Data Abort） | 如果数据访问指令的目标地址不存在，或者该地址不允许当前指令访问，处理器产生数据访问终止异常中断。
外部中断请求（IRQ） | 当处理器的外部中断请求引脚有效，而且CPSR寄存器的I控制位被清除时，处理器产生外部中断请求（IRQ）异常。系统中各外设通常通过该异常中断请求处理器服务。
快速中断请求（FIQ） | 当处理器的外部快速中断请求引脚有效，而且CPSR寄存器的F控制位被清除时，处理器产生外部中断请求（FIQ）异常中断。

## 2.异常中断向量表及异常中断优先级
中断向量表中指定了各异常中断及其处理程序的对应关系，他通常存放在存储地址的低端，在ARM体系中异常中断向量表大小为32字节，其中每个异常中断占据4个字节大小，保留了4个字节的空间。

每个异常中断对应的中断向量表中的四个字节的空间中存放了一个跳转指令，或者一个向程序计数器（PC）中赋值的数据访问指令。通过这两种指令，程序将跳转到相应的异常中断处理程序处执行。

当几个异常中断同时发生时，就必须按照一定的次序来处理这些异常中断。在ARM中，通过给各个异常中断赋予一定的优先级来实现这种处理次序。当然有些异常中断是不可能同时发生的，如指令预取中止异常中断（Prefetch Abort）和软件中断异常（SWI）中断是由同一条指令的执行触发的，他们是不可能同时发生的。处理器执行某个特定的异常中断的处理过程中，称为处理器处于特定的中断模式。
各异常中断的中断向量地址以及中断的优先级如下表：

中断向量地址 | 异常中断地址 | 异常中断模式 | 优先级1-6由高到低）
-| -|-| -
0x0 | 复位 | 管理模式（SVC） | 1
0x4 | 未定义的指令 | 未定义指令中断模式（Undef） | 6
0x8 | 软件中断（SWI） | 管理模式（SVC） | 6
0x0c | 指令预取中止 | 中止模式 | 5
0x10 | 数据访问中止 | 中止模式 | 2
0x14 | 保留 | 未使用 | 未使用 
0x18 | 外部中断请求（IRQ） | 外部中断（IRQ）模式 | 4
0x1c | 快速中断请求（FIQ） | 快速中断（FIQ）模式 | 3

## 3. 进入异常中断的过程
对于不同的异常中断处理程序，返回地址（LR）以及使用的指令是不同的。
1. 保存处理器当前状态、中断屏蔽位以及各条件标志位。这是通过将当前程序状态寄存器CPSR的内容保存到将要执行的异常中断对应的SPSR寄存器中实现的。各异常中断有自己的物理SPSR寄存器。
2. 设置当前状态寄存器CPSR中相应的位。包括设置CPSR中的位，使处理器进入相应的执行模式：设置CPSR中的位，禁止IRQ中断，当进入FIQ模式时，禁止FIQ中断。
3. 将寄存器LR_mode设置成返回地址。
4. 将程序计数器值（PC）设置成该异常中断的中断向量地址，从而跳转到相应的异常中断处理程序处执行。

上述处理器对异常中断的响应过程可以用如下的伪代码描述：
```sh
R14_<exception_mode> = return link
SPSR_<exception_mode> = CPSR
CPSR[4:0] = exception mode number   
#所有中断服务程序都运行在ARM状态，应设置处理器状态为ARM状态，而不去管原来的状态
CPSR[5] = 0
#如果中断类型为Reset或者FIQ，应该禁止新的FIQ中断
if <exception_mode> == Reset or FIQ then
    CPSR[6] = 1
fi
#禁止普通中断
CPSR[7] = 1
PC = exception vector address
```

>>这里注意，```R14_<exception_mode> = return link```这句话中的```return link```的计算方法可以参考上一章《1_模式与状态》的**ARM的状态切换**一节，上一章中只是一个简单的介绍，下一节会详细说明```return link```取值的原因。

下面介绍各种不同中断类型的响应过程：
### 3.1 响应复位异常中断
当处理器的复位引脚有效时，处理器终止当前指令。当处理器复位引脚由有效变成无效时，处理器执行下述操作：
```sh
R14_svc = UNPREDICTABLE value       #无需赋值
SPSR_svc = UNPREDICTABLE value      #无需赋值
#进入特权模式
CPSR[4:0] = 0b10011
#进入ARM状态
CPSR[5] = 0
#禁止FIQ中断
CPSR[6] = 1
#禁止IRQ中断
CPSR[7] = 1
if high vectors configured then
    PC = 0xFFFF0000
else
    PC = 0x00000000
fi
```
### 3.2 响应未定义指令异常中断
```sh
R14_und = address of next instruction after the undefined instruction
SPSR_und = CPSR
#进入未定义指令异常模式
CPSR[4:0] = 0b11011
#进入ARM状态
CPSR[5] = 0
#CPSR[6]不改变
#禁止IRQ中断
CPSR[7] = 1
if high vectors configured then
    PC = 0xFFFF0004             #中断向量
else
    PC = 0x00000004
fi
```

### 3.3 响应SWI异常中断时的处理过程如下面的伪代码所示：
```sh
R14_svc = address of next instruction after the SWI instruction
SPSR_svc = CPSR
#进入特权模式
CPSR[4:0] = 0b11011
#进入ARM状态
CPSR[5] = 0
#CPSR[6]不改变
#禁止IRQ中断
CPSR[7] = 1
if high vectors configured then
    PC = 0xFFFF0008             #中断向量
else
    PC = 0x00000008
fi
```

### 3.4 响应指令预取中止异常中断
```sh
R14_abt = address of the aborted instruction + 4
SPSR_abt = CPSR
#进入指令预取中止异常模式
CPSR[4:0] = 0b10111
#进入ARM状态
CPSR[5] = 0
#CPSR[6]不改变
#禁止IRQ中断
CPSR[7] = 1
if high vectors configured then
    PC = 0xFFFF000C             #中断向量
else
    PC = 0x0000000C
fi
```
### 3.5 响应数据访问中止异常中断
```sh
R14_abt = address of the aborted instruction + 8
SPSR_abt = CPSR
#进入指令预取中止异常模式
CPSR[4:0] = 0b10111
#进入ARM状态
CPSR[5] = 0
#CPSR[6]不改变
#禁止IRQ中断
CPSR[7] = 1
if high vectors configured then
    PC = 0xFFFF0010             #中断向量
else
    PC = 0x00000010
fi
```

### 3.6 响应IRQ异常中断
```sh
R14_irq = address of next instruction to be executed + 4
SPSR_irq = CPSR
#进入IRQ异常中断模式
CPSR[4:0] = 0b10010
#切换到ARM状态
CPSR[5] = 0
#CPSR[6]不改变
#禁止IRQ中断
CPSR[7] = 1
if high vectors configured then
    PC = 0xFFFF0018             #中断向量
else
    PC = 0x00000018
fi
```

### 3.7 响应FIQ异常中断
```sh
R14_fiq = address of next instruction to be executed + 4
SPSR_fiq = CPSR
#进入IRQ异常中断模式
CPSR[4:0] = 0b10001
#切换到ARM状态
CPSR[5] = 0
#禁止FIQ中断
CPSR[6] = 1
#禁止IRQ中断
CPSR[7] = 1
if high vectors configured then
    PC = 0xFFFF001C             #中断向量
else
    PC = 0x0000001C
fi
```
## 4. 从异常中断处理程序中返回
从异常中断处理程序中返回包括下面两个基本操作：
1. 恢复被中断的程序的处理器状态，即把SPSR_mode寄存器内容复制到当前程序状态寄存器CPSR。
2. 返回到发生异常中断的指令的下一条指令处执行，即把LR_mode寄存器的内容复制到程序计数器PC中。
   
复位异常中断处理程序不需要返回，因为整个应用系统是从复位异常中断处理程序开始执行的，因而它不需要返回。

实际上，当异常中断发生时，程序计数器PC所指的位置**对于各种不同的异常中断是不同的**。同样，返回地址对于各种不同的异常中断也是不同的。下面详细介绍各种异常中断的返回方法。

### 4.0 先介绍下ARM处理器的PC寄存器所指地址的意义。
ARM处理器采用流水线方式，相当于一条指令要经历3个阶段：预选->解析翻译->执行；在程序执行时，```PC-8```指向当前正在执行的指令，```PC-4```指向当前正在被解析的指令，```PC```指向当前被预选的指令。如果是Thumb状态，自然就是```PC-4，PC-2，PC```。
### 4.1 SWI和未定义指令异常中断处理程序的返回
SWI和未定义指令异常中断是由当前执行的指令自身产生的，当SWI和未定义指令异常中断产生时，程序计数器PC的值还没有更新，它指向当前指令后面第2条指令。当SWI和未定义指令异常中断发生时，处理器将值（PC-4）保存到异常模式下的寄存器LR_mode中。这时（PC-4）即指向当前指令的下一条指令。因此返回操作可以通过下面的指令来实现：
```ARM
MOV PC, LR
```

该指令将寄存器LR中的值复制到程序计数器PC中，实现程序返回，同时将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。

当异常中断处理程序中使用了数据栈时，可以通过使用下面的指令在进入异常中断处理程序时保存被中断程序的执行现场，在退出异常中断处理程序时恢复被中断程序的执行现场。异常中断处理程序使用的数据栈由用户提供。
```ARM
STMFD SP!, {reglist, lr}
; ...
LDMFD SP!, {reglist, pc}^
```

在上述指令中，reglist是异常中断处理程序中使用的寄存器列表。标识符^指示将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。该指令只能在特权模式下使用。
### 4.2 IRQ和FIQ异常中断处理程序的返回
通常，处理器执行完当前指令后，查询IRQ中断引脚即FIQ中断引脚，并且查询系统是否允许IRQ和FIQ中断。

如果有中断引脚有效，并且系统允许该中断产生，处理器将产生IRQ异常中断或FIQ异常中断。当IRQ或FIQ异常中断产生时，程序计数器PC的值已经更新，它指向当前指令后面第3条指令（对于ARM指令来说，他指向当前指令地址加12个字节的位置；对于Thumb指令来说，他指向当前指令地址加6个字节的位置）。当异常中断发生时，处理器将值（PC-4）保存到异常模式下的寄存器LR_mode中。这时（PC-4）即指向当前指令后的第二条指令，因此返回操作可以通过下面的指令来实现：
```ARM
SUBS PC, LR, #4
```
该指令将寄存器LR中的值减4后，复制到程序计数器PC中，实现程序返回，同时将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。

当异常中断处理程序中使用了数据栈时，可以通过下面的指令在进入异常中断处理程序时保存被中断程序的执行现场，在退出异常中断处理程序时恢复被中断程序的执行现场。异常中断处理程序中使用的数据栈由用户提供。
```ARM
SUBS LR, LR, #4
STMFD SP!, {reglist, LR}
;...
LDMFD SP!, {reglist, PC}^
```
在上述指令中，reglist是异常中断处理程序中使用的寄存器列表。标识符^指示将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。该指令只能在特权模式下使用。

### 4.3 指令预取终止异常中断处理程序的返回
在指令**预取**时，如果**目标地址是非法的**，该指令将被标记成有问题的指令。这时，流水线上该指令之前的指令继续执行。当执行到该被标记成有问题的指令时，处理器产生指令预取中止异常中断。

当发生指令预取中止异常中断时，**程序要返回到该有问题的指令处，重新读取并执行该指令**。因此指令预取中止异常中断程序应该返回到产生该指令预取中止异常中断的指令处，而不是像前面两种情况下返回到发生中断的指令的下一条指令处。

指令预取中止异常中断程序是由当前执行的指令自身产生的，当指令预取中止异常中断产生时，程序计数器PC的值还未更新，它指向当前指令后面第2条指令（对于ARM指令来说，它指向当前指令地址加8个字节的位置；对于Thumb指令来说，他指向当前指令地址加4个字节的位置）。当指令预取中止异常中断发生时，处理器将值（PC-4）保存到异常模式下的寄存器LR_mode中。这时（PC-4）即指向当前指令的下一条指令。因此返回操作可以通过下面的指令来实现：
```ARM
SUBS PC, LR, #4
```
该指令将寄存器LR中的值减4后，复制到程序计数器PC中，实现程序返回，同时将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。

当异常中断处理程序中使用了数据栈时，还可以通过下面的指令在进入异常中断处理程序时保存被中断程序的执行现场，在退出异常中断处理程序时恢复被中断程序的执行现场。异常中断处理程序中使用的数据栈由用户提供。
```ARM
SUBS PC, LR, #4 
STMFD SP!, {reglist, LR}
;...
LDMFD SP!, {reglist, PC}^
```

在上述指令中，reglist是异常中断处理程序中使用的寄存器列表。标识符^指示将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。该指令只能在特权模式下使用。

### 4.4数据访问中止异常中断处理程序的返回
当发生数据访问中止异常中断时，程序要返回到该有问题的数据访问指令处重新访问该数据，**因此数据访问中止异常中断程序应该返回到产生数据访问中止异常中断的指令处**，不是像前面4.1 4.2情况下返回到当前指令的下一条指令。

数据访问中止异常中断是由数据访问指令产生的，当数据访问终止异常中断产生时，程序计数器PC的值已经更新，它指向当前指令后面的第二条指令（对于ARM指令来说，它指向当前指令地址加8个字节的位置；对于Thumb指令来说，它指向当前指令地址加4个字节的位置。）当数据访问终止异常中断发生时，处理器将值（PC-4）保存到异常模式下的寄存器LR_mode中，而这时（PC-4）指向当前指令后的第二条指令。因此返回操作可以通过下面的指令来实现：
```ARM
SUBS PC, LR, #8
```
该指令将寄存器LR中的值减8后，复制到程序计数器PC中，实现程序返回，同时将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。

当异常中断处理程序中使用了数据栈时，还可以通过下面的指令在进入异常中断处理程序时保存被中断程序的执行现场，在退出异常中断处理程序时恢复被中断程序的执行现场。异常中断处理程序中使用的数据栈由用户提供。

```ARM
SUBS LR, LR, #8
STMFD SP!, {reglist, LR}
;...
LDMFD SP!, {reglist, PC}^
```
在上述指令中，reglist是异常中断处理程序中使用的寄存器列表。标识符^指示将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。该指令只能在特权模式下使用。





 













 
